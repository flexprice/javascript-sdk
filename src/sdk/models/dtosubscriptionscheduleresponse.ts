/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import {
  ScheduleStatus,
  ScheduleStatus$inboundSchema,
} from "./schedulestatus.js";
import { SDKValidationError } from "./sdkvalidationerror.js";
import {
  SubscriptionScheduleChangeType,
  SubscriptionScheduleChangeType$inboundSchema,
} from "./subscriptionschedulechangetype.js";

/**
 * configuration contains type-specific configuration (e.g., target_plan_id for plan changes)
 */
export type Configuration = {};

/**
 * execution_result contains type-specific execution result
 */
export type ExecutionResult = {};

/**
 * Full details of a subscription schedule
 */
export type DtoSubscriptionScheduleResponse = {
  /**
   * can_be_cancelled indicates if the schedule can be cancelled
   */
  canBeCancelled?: boolean | undefined;
  /**
   * cancelled_at is when the schedule was cancelled
   */
  cancelledAt?: string | undefined;
  /**
   * configuration contains type-specific configuration (e.g., target_plan_id for plan changes)
   */
  configuration?: Configuration | undefined;
  /**
   * created_at timestamp
   */
  createdAt?: string | undefined;
  /**
   * days_until_execution is the number of days until execution
   */
  daysUntilExecution?: number | undefined;
  /**
   * error_message contains the error if execution failed
   */
  errorMessage?: string | undefined;
  /**
   * executed_at is when the schedule was executed
   */
  executedAt?: string | undefined;
  /**
   * execution_result contains type-specific execution result
   */
  executionResult?: ExecutionResult | undefined;
  /**
   * id of the schedule
   */
  id?: string | undefined;
  /**
   * metadata from the schedule
   */
  metadata?: { [k: string]: string } | undefined;
  scheduleType?: SubscriptionScheduleChangeType | undefined;
  /**
   * scheduled_at is when the schedule will execute
   */
  scheduledAt?: string | undefined;
  status?: ScheduleStatus | undefined;
  /**
   * subscription_id is the ID of the subscription
   */
  subscriptionId?: string | undefined;
  /**
   * updated_at timestamp
   */
  updatedAt?: string | undefined;
};

/** @internal */
export const Configuration$inboundSchema: z.ZodType<
  Configuration,
  z.ZodTypeDef,
  unknown
> = z.object({});

export function configurationFromJSON(
  jsonString: string,
): SafeParseResult<Configuration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Configuration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Configuration' from JSON`,
  );
}

/** @internal */
export const ExecutionResult$inboundSchema: z.ZodType<
  ExecutionResult,
  z.ZodTypeDef,
  unknown
> = z.object({});

export function executionResultFromJSON(
  jsonString: string,
): SafeParseResult<ExecutionResult, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExecutionResult$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExecutionResult' from JSON`,
  );
}

/** @internal */
export const DtoSubscriptionScheduleResponse$inboundSchema: z.ZodType<
  DtoSubscriptionScheduleResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  can_be_cancelled: z.boolean().optional(),
  cancelled_at: z.string().optional(),
  configuration: z.lazy(() => Configuration$inboundSchema).optional(),
  created_at: z.string().optional(),
  days_until_execution: z.number().int().optional(),
  error_message: z.string().optional(),
  executed_at: z.string().optional(),
  execution_result: z.lazy(() => ExecutionResult$inboundSchema).optional(),
  id: z.string().optional(),
  metadata: z.record(z.string()).optional(),
  schedule_type: SubscriptionScheduleChangeType$inboundSchema.optional(),
  scheduled_at: z.string().optional(),
  status: ScheduleStatus$inboundSchema.optional(),
  subscription_id: z.string().optional(),
  updated_at: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "can_be_cancelled": "canBeCancelled",
    "cancelled_at": "cancelledAt",
    "created_at": "createdAt",
    "days_until_execution": "daysUntilExecution",
    "error_message": "errorMessage",
    "executed_at": "executedAt",
    "execution_result": "executionResult",
    "schedule_type": "scheduleType",
    "scheduled_at": "scheduledAt",
    "subscription_id": "subscriptionId",
    "updated_at": "updatedAt",
  });
});

export function dtoSubscriptionScheduleResponseFromJSON(
  jsonString: string,
): SafeParseResult<DtoSubscriptionScheduleResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DtoSubscriptionScheduleResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DtoSubscriptionScheduleResponse' from JSON`,
  );
}
