/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "./sdk-validation-error.js";

export type DtoCustomerInvoiceSummary = {
  /**
   * currency is the three-letter ISO currency code for this summary
   */
  currency?: string | undefined;
  /**
   * customer_id is the unique identifier of the customer
   */
  customerId?: string | undefined;
  /**
   * overdue_invoice_count is the number of overdue invoices for this customer in this currency
   */
  overdueInvoiceCount?: number | undefined;
  /**
   * total_invoice_count is the total number of invoices for this customer in this currency
   */
  totalInvoiceCount?: number | undefined;
  /**
   * total_overdue_amount is the total amount of overdue invoices in this currency
   */
  totalOverdueAmount?: string | undefined;
  /**
   * total_revenue_amount is the total revenue generated from this customer in this currency
   */
  totalRevenueAmount?: string | undefined;
  /**
   * total_unpaid_amount is the total amount of unpaid invoices in this currency
   */
  totalUnpaidAmount?: string | undefined;
  /**
   * unpaid_fixed_charges is the total amount of unpaid fixed charges in this currency
   */
  unpaidFixedCharges?: string | undefined;
  /**
   * unpaid_invoice_count is the number of unpaid invoices for this customer in this currency
   */
  unpaidInvoiceCount?: number | undefined;
  /**
   * unpaid_usage_charges is the total amount of unpaid usage-based charges in this currency
   */
  unpaidUsageCharges?: string | undefined;
};

/** @internal */
export const DtoCustomerInvoiceSummary$inboundSchema: z.ZodMiniType<
  DtoCustomerInvoiceSummary,
  unknown
> = z.pipe(
  z.object({
    currency: types.optional(types.string()),
    customer_id: types.optional(types.string()),
    overdue_invoice_count: types.optional(types.number()),
    total_invoice_count: types.optional(types.number()),
    total_overdue_amount: types.optional(types.string()),
    total_revenue_amount: types.optional(types.string()),
    total_unpaid_amount: types.optional(types.string()),
    unpaid_fixed_charges: types.optional(types.string()),
    unpaid_invoice_count: types.optional(types.number()),
    unpaid_usage_charges: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "customer_id": "customerId",
      "overdue_invoice_count": "overdueInvoiceCount",
      "total_invoice_count": "totalInvoiceCount",
      "total_overdue_amount": "totalOverdueAmount",
      "total_revenue_amount": "totalRevenueAmount",
      "total_unpaid_amount": "totalUnpaidAmount",
      "unpaid_fixed_charges": "unpaidFixedCharges",
      "unpaid_invoice_count": "unpaidInvoiceCount",
      "unpaid_usage_charges": "unpaidUsageCharges",
    });
  }),
);

export function dtoCustomerInvoiceSummaryFromJSON(
  jsonString: string,
): SafeParseResult<DtoCustomerInvoiceSummary, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DtoCustomerInvoiceSummary$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DtoCustomerInvoiceSummary' from JSON`,
  );
}
