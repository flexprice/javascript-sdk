/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import {
  AlertSettings,
  AlertSettings$inboundSchema,
} from "./alert-settings.js";
import { AlertState, AlertState$inboundSchema } from "./alert-state.js";
import { AutoTopup, AutoTopup$inboundSchema } from "./auto-topup.js";
import {
  CreditBreakdown,
  CreditBreakdown$inboundSchema,
} from "./credit-breakdown.js";
import { SDKValidationError } from "./sdk-validation-error.js";
import { Status, Status$inboundSchema } from "./status.js";
import { WalletConfig, WalletConfig$inboundSchema } from "./wallet-config.js";
import { WalletStatus, WalletStatus$inboundSchema } from "./wallet-status.js";
import { WalletType, WalletType$inboundSchema } from "./wallet-type.js";

export type DtoWalletBalanceResponse = {
  alertSettings?: AlertSettings | undefined;
  alertState?: AlertState | undefined;
  autoTopup?: AutoTopup | undefined;
  balance?: string | undefined;
  balanceUpdatedAt?: string | undefined;
  config?: WalletConfig | undefined;
  /**
   * amount in the currency =  number of credits * conversion_rate
   *
   * @remarks
   * ex if conversion_rate is 1, then 1 USD = 1 credit
   * ex if conversion_rate is 2, then 1 USD = 0.5 credits
   * ex if conversion_rate is 0.5, then 1 USD = 2 credits
   */
  conversionRate?: string | undefined;
  createdAt?: string | undefined;
  createdBy?: string | undefined;
  creditBalance?: string | undefined;
  creditsAvailableBreakdown?: CreditBreakdown | undefined;
  currency?: string | undefined;
  currentPeriodUsage?: string | undefined;
  customerId?: string | undefined;
  description?: string | undefined;
  environmentId?: string | undefined;
  id?: string | undefined;
  metadata?: { [k: string]: string } | undefined;
  name?: string | undefined;
  realTimeBalance?: string | undefined;
  realTimeCreditBalance?: string | undefined;
  status?: Status | undefined;
  tenantId?: string | undefined;
  /**
   * topup_conversion_rate is the conversion rate for the topup to the currency
   *
   * @remarks
   * ex if topup_conversion_rate is 1, then 1 USD = 1 credit
   * ex if topup_conversion_rate is 2, then 1 USD = 0.5 credits
   * ex if topup_conversion_rate is 0.5, then 1 USD = 2 credits
   */
  topupConversionRate?: string | undefined;
  unpaidInvoicesAmount?: string | undefined;
  updatedAt?: string | undefined;
  updatedBy?: string | undefined;
  walletStatus?: WalletStatus | undefined;
  walletType?: WalletType | undefined;
};

/** @internal */
export const DtoWalletBalanceResponse$inboundSchema: z.ZodMiniType<
  DtoWalletBalanceResponse,
  unknown
> = z.pipe(
  z.object({
    alert_settings: types.optional(AlertSettings$inboundSchema),
    alert_state: types.optional(AlertState$inboundSchema),
    auto_topup: types.optional(AutoTopup$inboundSchema),
    balance: types.optional(types.string()),
    balance_updated_at: types.optional(types.string()),
    config: types.optional(WalletConfig$inboundSchema),
    conversion_rate: types.optional(types.string()),
    created_at: types.optional(types.string()),
    created_by: types.optional(types.string()),
    credit_balance: types.optional(types.string()),
    credits_available_breakdown: types.optional(CreditBreakdown$inboundSchema),
    currency: types.optional(types.string()),
    current_period_usage: types.optional(types.string()),
    customer_id: types.optional(types.string()),
    description: types.optional(types.string()),
    environment_id: types.optional(types.string()),
    id: types.optional(types.string()),
    metadata: types.optional(z.record(z.string(), types.string())),
    name: types.optional(types.string()),
    real_time_balance: types.optional(types.string()),
    real_time_credit_balance: types.optional(types.string()),
    status: types.optional(Status$inboundSchema),
    tenant_id: types.optional(types.string()),
    topup_conversion_rate: types.optional(types.string()),
    unpaid_invoices_amount: types.optional(types.string()),
    updated_at: types.optional(types.string()),
    updated_by: types.optional(types.string()),
    wallet_status: types.optional(WalletStatus$inboundSchema),
    wallet_type: types.optional(WalletType$inboundSchema),
  }),
  z.transform((v) => {
    return remap$(v, {
      "alert_settings": "alertSettings",
      "alert_state": "alertState",
      "auto_topup": "autoTopup",
      "balance_updated_at": "balanceUpdatedAt",
      "conversion_rate": "conversionRate",
      "created_at": "createdAt",
      "created_by": "createdBy",
      "credit_balance": "creditBalance",
      "credits_available_breakdown": "creditsAvailableBreakdown",
      "current_period_usage": "currentPeriodUsage",
      "customer_id": "customerId",
      "environment_id": "environmentId",
      "real_time_balance": "realTimeBalance",
      "real_time_credit_balance": "realTimeCreditBalance",
      "tenant_id": "tenantId",
      "topup_conversion_rate": "topupConversionRate",
      "unpaid_invoices_amount": "unpaidInvoicesAmount",
      "updated_at": "updatedAt",
      "updated_by": "updatedBy",
      "wallet_status": "walletStatus",
      "wallet_type": "walletType",
    });
  }),
);

export function dtoWalletBalanceResponseFromJSON(
  jsonString: string,
): SafeParseResult<DtoWalletBalanceResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DtoWalletBalanceResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DtoWalletBalanceResponse' from JSON`,
  );
}
