/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import {
  ScheduleStatus,
  ScheduleStatus$inboundSchema,
} from "./schedule-status.js";
import { SDKValidationError } from "./sdk-validation-error.js";
import {
  SubscriptionScheduleChangeType,
  SubscriptionScheduleChangeType$inboundSchema,
} from "./subscription-schedule-change-type.js";

/**
 * configuration contains type-specific configuration (e.g., target_plan_id for plan changes)
 */
export type Configuration = {};

/**
 * execution_result contains type-specific execution result
 */
export type ExecutionResult = {};

/**
 * Full details of a subscription schedule
 */
export type DtoSubscriptionScheduleResponse = {
  /**
   * can_be_cancelled indicates if the schedule can be cancelled
   */
  canBeCancelled?: boolean | undefined;
  /**
   * cancelled_at is when the schedule was cancelled
   */
  cancelledAt?: string | undefined;
  /**
   * configuration contains type-specific configuration (e.g., target_plan_id for plan changes)
   */
  configuration?: Configuration | undefined;
  /**
   * created_at timestamp
   */
  createdAt?: string | undefined;
  /**
   * days_until_execution is the number of days until execution
   */
  daysUntilExecution?: number | undefined;
  /**
   * error_message contains the error if execution failed
   */
  errorMessage?: string | undefined;
  /**
   * executed_at is when the schedule was executed
   */
  executedAt?: string | undefined;
  /**
   * execution_result contains type-specific execution result
   */
  executionResult?: ExecutionResult | undefined;
  /**
   * id of the schedule
   */
  id?: string | undefined;
  /**
   * metadata from the schedule
   */
  metadata?: { [k: string]: string } | undefined;
  scheduleType?: SubscriptionScheduleChangeType | undefined;
  /**
   * scheduled_at is when the schedule will execute
   */
  scheduledAt?: string | undefined;
  status?: ScheduleStatus | undefined;
  /**
   * subscription_id is the ID of the subscription
   */
  subscriptionId?: string | undefined;
  /**
   * updated_at timestamp
   */
  updatedAt?: string | undefined;
};

/** @internal */
export const Configuration$inboundSchema: z.ZodMiniType<
  Configuration,
  unknown
> = z.object({});

export function configurationFromJSON(
  jsonString: string,
): SafeParseResult<Configuration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Configuration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Configuration' from JSON`,
  );
}

/** @internal */
export const ExecutionResult$inboundSchema: z.ZodMiniType<
  ExecutionResult,
  unknown
> = z.object({});

export function executionResultFromJSON(
  jsonString: string,
): SafeParseResult<ExecutionResult, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExecutionResult$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExecutionResult' from JSON`,
  );
}

/** @internal */
export const DtoSubscriptionScheduleResponse$inboundSchema: z.ZodMiniType<
  DtoSubscriptionScheduleResponse,
  unknown
> = z.pipe(
  z.object({
    can_be_cancelled: types.optional(types.boolean()),
    cancelled_at: types.optional(types.string()),
    configuration: types.optional(z.lazy(() => Configuration$inboundSchema)),
    created_at: types.optional(types.string()),
    days_until_execution: types.optional(types.number()),
    error_message: types.optional(types.string()),
    executed_at: types.optional(types.string()),
    execution_result: types.optional(
      z.lazy(() => ExecutionResult$inboundSchema),
    ),
    id: types.optional(types.string()),
    metadata: types.optional(z.record(z.string(), types.string())),
    schedule_type: types.optional(SubscriptionScheduleChangeType$inboundSchema),
    scheduled_at: types.optional(types.string()),
    status: types.optional(ScheduleStatus$inboundSchema),
    subscription_id: types.optional(types.string()),
    updated_at: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "can_be_cancelled": "canBeCancelled",
      "cancelled_at": "cancelledAt",
      "created_at": "createdAt",
      "days_until_execution": "daysUntilExecution",
      "error_message": "errorMessage",
      "executed_at": "executedAt",
      "execution_result": "executionResult",
      "schedule_type": "scheduleType",
      "scheduled_at": "scheduledAt",
      "subscription_id": "subscriptionId",
      "updated_at": "updatedAt",
    });
  }),
);

export function dtoSubscriptionScheduleResponseFromJSON(
  jsonString: string,
): SafeParseResult<DtoSubscriptionScheduleResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DtoSubscriptionScheduleResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DtoSubscriptionScheduleResponse' from JSON`,
  );
}
