/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { DtoCostPoint, DtoCostPoint$inboundSchema } from "./dto-cost-point.js";
import { MeterMeter, MeterMeter$inboundSchema } from "./meter-meter.js";
import { PricePrice, PricePrice$inboundSchema } from "./price-price.js";
import { SDKValidationError } from "./sdk-validation-error.js";

export type DtoCostAnalyticItem = {
  /**
   * Breakdown
   */
  costByPeriod?: Array<DtoCostPoint> | undefined;
  costsheetId?: string | undefined;
  /**
   * Metadata
   */
  currency?: string | undefined;
  customerId?: string | undefined;
  externalCustomerId?: string | undefined;
  meter?: MeterMeter | undefined;
  meterId?: string | undefined;
  meterName?: string | undefined;
  price?: PricePrice | undefined;
  priceId?: string | undefined;
  properties?: { [k: string]: string } | undefined;
  source?: string | undefined;
  /**
   * Aggregated metrics
   */
  totalCost?: string | undefined;
  totalEvents?: number | undefined;
  totalQuantity?: string | undefined;
};

/** @internal */
export const DtoCostAnalyticItem$inboundSchema: z.ZodMiniType<
  DtoCostAnalyticItem,
  unknown
> = z.pipe(
  z.object({
    cost_by_period: types.optional(z.array(DtoCostPoint$inboundSchema)),
    costsheet_id: types.optional(types.string()),
    currency: types.optional(types.string()),
    customer_id: types.optional(types.string()),
    external_customer_id: types.optional(types.string()),
    meter: types.optional(MeterMeter$inboundSchema),
    meter_id: types.optional(types.string()),
    meter_name: types.optional(types.string()),
    price: types.optional(PricePrice$inboundSchema),
    price_id: types.optional(types.string()),
    properties: types.optional(z.record(z.string(), types.string())),
    source: types.optional(types.string()),
    total_cost: types.optional(types.string()),
    total_events: types.optional(types.number()),
    total_quantity: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "cost_by_period": "costByPeriod",
      "costsheet_id": "costsheetId",
      "customer_id": "customerId",
      "external_customer_id": "externalCustomerId",
      "meter_id": "meterId",
      "meter_name": "meterName",
      "price_id": "priceId",
      "total_cost": "totalCost",
      "total_events": "totalEvents",
      "total_quantity": "totalQuantity",
    });
  }),
);

export function dtoCostAnalyticItemFromJSON(
  jsonString: string,
): SafeParseResult<DtoCostAnalyticItem, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DtoCostAnalyticItem$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DtoCostAnalyticItem' from JSON`,
  );
}
