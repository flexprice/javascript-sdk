/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import {
  DtoCouponApplicationResponse,
  DtoCouponApplicationResponse$inboundSchema,
} from "./dtocouponapplicationresponse.js";
import {
  DtoCustomerResponse,
  DtoCustomerResponse$inboundSchema,
} from "./dtocustomerresponse.js";
import {
  DtoInvoiceLineItemResponse,
  DtoInvoiceLineItemResponse$inboundSchema,
} from "./dtoinvoicelineitemresponse.js";
import {
  DtoSubscriptionResponse,
  DtoSubscriptionResponse$inboundSchema,
} from "./dtosubscriptionresponse.js";
import {
  DtoTaxAppliedResponse,
  DtoTaxAppliedResponse$inboundSchema,
} from "./dtotaxappliedresponse.js";
import { InvoiceStatus, InvoiceStatus$inboundSchema } from "./invoicestatus.js";
import { InvoiceType, InvoiceType$inboundSchema } from "./invoicetype.js";
import { PaymentStatus, PaymentStatus$inboundSchema } from "./paymentstatus.js";
import { SDKValidationError } from "./sdkvalidationerror.js";
import { Status, Status$inboundSchema } from "./status.js";

export type DtoInvoiceResponse = {
  /**
   * adjustment_amount is the total sum of credit notes of type "adjustment".
   *
   * @remarks
   * These are non-cash reductions applied to the invoice (e.g. goodwill credit, billing correction).
   */
  adjustmentAmount?: string | undefined;
  /**
   * amount_due is the total amount that needs to be paid for this invoice
   */
  amountDue?: string | undefined;
  /**
   * amount_paid is the amount that has already been paid towards this invoice
   */
  amountPaid?: string | undefined;
  /**
   * amount_remaining is the outstanding amount still owed on this invoice (calculated as amount_due minus amount_paid)
   */
  amountRemaining?: string | undefined;
  /**
   * billing_period describes the billing period this invoice covers (e.g., "January 2024", "Q1 2024")
   */
  billingPeriod?: string | undefined;
  /**
   * billing_reason indicates why this invoice was generated (e.g., "subscription_billing", "manual_charge")
   */
  billingReason?: string | undefined;
  /**
   * billing_sequence is the sequential number indicating the billing cycle for subscription invoices
   */
  billingSequence?: number | undefined;
  /**
   * coupon_applications contains the coupon applications associated with this invoice (overrides embedded field)
   */
  couponApplications?: Array<DtoCouponApplicationResponse> | undefined;
  createdAt?: string | undefined;
  createdBy?: string | undefined;
  /**
   * currency is the three-letter ISO currency code (e.g., USD, EUR, GBP) that applies to all monetary amounts on this invoice
   */
  currency?: string | undefined;
  /**
   * Customer response object containing all customer information
   */
  customer?: DtoCustomerResponse | undefined;
  /**
   * customer_id is the ID of the customer who will receive this invoice
   */
  customerId?: string | undefined;
  /**
   * description is an optional description or notes about this invoice
   */
  description?: string | undefined;
  /**
   * due_date is the date when payment for this invoice is due
   */
  dueDate?: string | undefined;
  /**
   * environment_id is the ID of the environment this invoice belongs to (for multi-environment setups)
   */
  environmentId?: string | undefined;
  /**
   * finalized_at is the timestamp when this invoice was finalized and made ready for payment
   */
  finalizedAt?: string | undefined;
  /**
   * id is the unique identifier for this invoice
   */
  id?: string | undefined;
  /**
   * idempotency_key is a unique key used to prevent duplicate invoice creation when retrying API calls
   */
  idempotencyKey?: string | undefined;
  /**
   * invoice_number is the human-readable invoice number displayed to customers (e.g., INV-2024-001)
   */
  invoiceNumber?: string | undefined;
  /**
   * invoice_pdf_url is the URL where customers can download the PDF version of this invoice
   */
  invoicePdfUrl?: string | undefined;
  invoiceStatus?: InvoiceStatus | undefined;
  invoiceType?: InvoiceType | undefined;
  /**
   * line_items contains the individual items that make up this invoice (overrides embedded field)
   */
  lineItems?: Array<DtoInvoiceLineItemResponse> | undefined;
  metadata?: { [k: string]: string } | undefined;
  /**
   * overpaid_amount is the amount overpaid if payment_status is OVERPAID (amount_paid - total)
   */
  overpaidAmount?: string | undefined;
  /**
   * paid_at is the timestamp when this invoice was fully paid
   */
  paidAt?: string | undefined;
  paymentStatus?: PaymentStatus | undefined;
  /**
   * period_end is the end date of the billing period covered by this invoice
   */
  periodEnd?: string | undefined;
  /**
   * period_start is the start date of the billing period covered by this invoice
   */
  periodStart?: string | undefined;
  /**
   * refunded_amount is the total sum of credit notes of type "refund".
   *
   * @remarks
   * These are actual refunds issued to the customer.
   */
  refundedAmount?: string | undefined;
  status?: Status | undefined;
  subscription?: DtoSubscriptionResponse | undefined;
  /**
   * subscription_id is the ID of the subscription this invoice is associated with (only present for subscription-based invoices)
   */
  subscriptionId?: string | undefined;
  /**
   * subtotal is the sum of all line items before any taxes, discounts, or additional fees
   */
  subtotal?: string | undefined;
  /**
   * tax_applied_records contains the tax applied records associated with this invoice
   */
  taxes?: Array<DtoTaxAppliedResponse> | undefined;
  tenantId?: string | undefined;
  /**
   * total is the final amount including taxes, fees, and discounts
   */
  total?: string | undefined;
  /**
   * total_discount is the sum of all coupon discounts applied to the invoice
   */
  totalDiscount?: string | undefined;
  /**
   * total_prepaid_credits_applied is the total amount of prepaid credits applied to this invoice.
   */
  totalPrepaidCreditsApplied?: string | undefined;
  /**
   * total_tax is the sum of all taxes combined at the invoice level.
   */
  totalTax?: string | undefined;
  updatedAt?: string | undefined;
  updatedBy?: string | undefined;
  /**
   * version is the version number for tracking changes to this invoice
   */
  version?: number | undefined;
  /**
   * voided_at is the timestamp when this invoice was voided or cancelled
   */
  voidedAt?: string | undefined;
};

/** @internal */
export const DtoInvoiceResponse$inboundSchema: z.ZodType<
  DtoInvoiceResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  adjustment_amount: z.string().optional(),
  amount_due: z.string().optional(),
  amount_paid: z.string().optional(),
  amount_remaining: z.string().optional(),
  billing_period: z.string().optional(),
  billing_reason: z.string().optional(),
  billing_sequence: z.number().int().optional(),
  coupon_applications: z.array(DtoCouponApplicationResponse$inboundSchema)
    .optional(),
  created_at: z.string().optional(),
  created_by: z.string().optional(),
  currency: z.string().optional(),
  customer: DtoCustomerResponse$inboundSchema.optional(),
  customer_id: z.string().optional(),
  description: z.string().optional(),
  due_date: z.string().optional(),
  environment_id: z.string().optional(),
  finalized_at: z.string().optional(),
  id: z.string().optional(),
  idempotency_key: z.string().optional(),
  invoice_number: z.string().optional(),
  invoice_pdf_url: z.string().optional(),
  invoice_status: InvoiceStatus$inboundSchema.optional(),
  invoice_type: InvoiceType$inboundSchema.optional(),
  line_items: z.array(DtoInvoiceLineItemResponse$inboundSchema).optional(),
  metadata: z.record(z.string()).optional(),
  overpaid_amount: z.string().optional(),
  paid_at: z.string().optional(),
  payment_status: PaymentStatus$inboundSchema.optional(),
  period_end: z.string().optional(),
  period_start: z.string().optional(),
  refunded_amount: z.string().optional(),
  status: Status$inboundSchema.optional(),
  subscription: z.lazy(() => DtoSubscriptionResponse$inboundSchema).optional(),
  subscription_id: z.string().optional(),
  subtotal: z.string().optional(),
  taxes: z.array(DtoTaxAppliedResponse$inboundSchema).optional(),
  tenant_id: z.string().optional(),
  total: z.string().optional(),
  total_discount: z.string().optional(),
  total_prepaid_credits_applied: z.string().optional(),
  total_tax: z.string().optional(),
  updated_at: z.string().optional(),
  updated_by: z.string().optional(),
  version: z.number().int().optional(),
  voided_at: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "adjustment_amount": "adjustmentAmount",
    "amount_due": "amountDue",
    "amount_paid": "amountPaid",
    "amount_remaining": "amountRemaining",
    "billing_period": "billingPeriod",
    "billing_reason": "billingReason",
    "billing_sequence": "billingSequence",
    "coupon_applications": "couponApplications",
    "created_at": "createdAt",
    "created_by": "createdBy",
    "customer_id": "customerId",
    "due_date": "dueDate",
    "environment_id": "environmentId",
    "finalized_at": "finalizedAt",
    "idempotency_key": "idempotencyKey",
    "invoice_number": "invoiceNumber",
    "invoice_pdf_url": "invoicePdfUrl",
    "invoice_status": "invoiceStatus",
    "invoice_type": "invoiceType",
    "line_items": "lineItems",
    "overpaid_amount": "overpaidAmount",
    "paid_at": "paidAt",
    "payment_status": "paymentStatus",
    "period_end": "periodEnd",
    "period_start": "periodStart",
    "refunded_amount": "refundedAmount",
    "subscription_id": "subscriptionId",
    "tenant_id": "tenantId",
    "total_discount": "totalDiscount",
    "total_prepaid_credits_applied": "totalPrepaidCreditsApplied",
    "total_tax": "totalTax",
    "updated_at": "updatedAt",
    "updated_by": "updatedBy",
    "voided_at": "voidedAt",
  });
});

export function dtoInvoiceResponseFromJSON(
  jsonString: string,
): SafeParseResult<DtoInvoiceResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DtoInvoiceResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DtoInvoiceResponse' from JSON`,
  );
}
