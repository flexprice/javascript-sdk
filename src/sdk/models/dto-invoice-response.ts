/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import {
  DtoCouponApplicationResponse,
  DtoCouponApplicationResponse$inboundSchema,
} from "./dto-coupon-application-response.js";
import {
  DtoCustomerResponse,
  DtoCustomerResponse$inboundSchema,
} from "./dto-customer-response.js";
import {
  DtoInvoiceLineItemResponse,
  DtoInvoiceLineItemResponse$inboundSchema,
} from "./dto-invoice-line-item-response.js";
import {
  DtoSubscriptionResponse,
  DtoSubscriptionResponse$inboundSchema,
} from "./dto-subscription-response.js";
import {
  DtoTaxAppliedResponse,
  DtoTaxAppliedResponse$inboundSchema,
} from "./dto-tax-applied-response.js";
import {
  InvoiceStatus,
  InvoiceStatus$inboundSchema,
} from "./invoice-status.js";
import { InvoiceType, InvoiceType$inboundSchema } from "./invoice-type.js";
import {
  PaymentStatus,
  PaymentStatus$inboundSchema,
} from "./payment-status.js";
import { SDKValidationError } from "./sdk-validation-error.js";
import { Status, Status$inboundSchema } from "./status.js";

export type DtoInvoiceResponse = {
  /**
   * adjustment_amount is the total sum of credit notes of type "adjustment".
   *
   * @remarks
   * These are non-cash reductions applied to the invoice (e.g. goodwill credit, billing correction).
   */
  adjustmentAmount?: string | undefined;
  /**
   * amount_due is the total amount that needs to be paid for this invoice
   */
  amountDue?: string | undefined;
  /**
   * amount_paid is the amount that has already been paid towards this invoice
   */
  amountPaid?: string | undefined;
  /**
   * amount_remaining is the outstanding amount still owed on this invoice (calculated as amount_due minus amount_paid)
   */
  amountRemaining?: string | undefined;
  /**
   * billing_period describes the billing period this invoice covers (e.g., "January 2024", "Q1 2024")
   */
  billingPeriod?: string | undefined;
  /**
   * billing_reason indicates why this invoice was generated (e.g., "subscription_billing", "manual_charge")
   */
  billingReason?: string | undefined;
  /**
   * billing_sequence is the sequential number indicating the billing cycle for subscription invoices
   */
  billingSequence?: number | undefined;
  /**
   * coupon_applications contains the coupon applications associated with this invoice (overrides embedded field)
   */
  couponApplications?: Array<DtoCouponApplicationResponse> | undefined;
  createdAt?: string | undefined;
  createdBy?: string | undefined;
  /**
   * currency is the three-letter ISO currency code (e.g., USD, EUR, GBP) that applies to all monetary amounts on this invoice
   */
  currency?: string | undefined;
  /**
   * Customer response object containing all customer information
   */
  customer?: DtoCustomerResponse | undefined;
  /**
   * customer_id is the ID of the customer who will receive this invoice
   */
  customerId?: string | undefined;
  /**
   * description is an optional description or notes about this invoice
   */
  description?: string | undefined;
  /**
   * due_date is the date when payment for this invoice is due
   */
  dueDate?: string | undefined;
  /**
   * environment_id is the ID of the environment this invoice belongs to (for multi-environment setups)
   */
  environmentId?: string | undefined;
  /**
   * finalized_at is the timestamp when this invoice was finalized and made ready for payment
   */
  finalizedAt?: string | undefined;
  /**
   * id is the unique identifier for this invoice
   */
  id?: string | undefined;
  /**
   * idempotency_key is a unique key used to prevent duplicate invoice creation when retrying API calls
   */
  idempotencyKey?: string | undefined;
  /**
   * invoice_number is the human-readable invoice number displayed to customers (e.g., INV-2024-001)
   */
  invoiceNumber?: string | undefined;
  /**
   * invoice_pdf_url is the URL where customers can download the PDF version of this invoice
   */
  invoicePdfUrl?: string | undefined;
  invoiceStatus?: InvoiceStatus | undefined;
  invoiceType?: InvoiceType | undefined;
  /**
   * line_items contains the individual items that make up this invoice (overrides embedded field)
   */
  lineItems?: Array<DtoInvoiceLineItemResponse> | undefined;
  metadata?: { [k: string]: string } | undefined;
  /**
   * overpaid_amount is the amount overpaid if payment_status is OVERPAID (amount_paid - total)
   */
  overpaidAmount?: string | undefined;
  /**
   * paid_at is the timestamp when this invoice was fully paid
   */
  paidAt?: string | undefined;
  paymentStatus?: PaymentStatus | undefined;
  /**
   * period_end is the end date of the billing period covered by this invoice
   */
  periodEnd?: string | undefined;
  /**
   * period_start is the start date of the billing period covered by this invoice
   */
  periodStart?: string | undefined;
  /**
   * refunded_amount is the total sum of credit notes of type "refund".
   *
   * @remarks
   * These are actual refunds issued to the customer.
   */
  refundedAmount?: string | undefined;
  status?: Status | undefined;
  subscription?: DtoSubscriptionResponse | undefined;
  /**
   * subscription_id is the ID of the subscription this invoice is associated with (only present for subscription-based invoices)
   */
  subscriptionId?: string | undefined;
  /**
   * subtotal is the sum of all line items before any taxes, discounts, or additional fees
   */
  subtotal?: string | undefined;
  /**
   * tax_applied_records contains the tax applied records associated with this invoice
   */
  taxes?: Array<DtoTaxAppliedResponse> | undefined;
  tenantId?: string | undefined;
  /**
   * total is the final amount including taxes, fees, and discounts
   */
  total?: string | undefined;
  /**
   * total_discount is the sum of all coupon discounts applied to the invoice
   */
  totalDiscount?: string | undefined;
  /**
   * total_prepaid_credits_applied is the total amount of prepaid credits applied to this invoice.
   */
  totalPrepaidCreditsApplied?: string | undefined;
  /**
   * total_tax is the sum of all taxes combined at the invoice level.
   */
  totalTax?: string | undefined;
  updatedAt?: string | undefined;
  updatedBy?: string | undefined;
  /**
   * version is the version number for tracking changes to this invoice
   */
  version?: number | undefined;
  /**
   * voided_at is the timestamp when this invoice was voided or cancelled
   */
  voidedAt?: string | undefined;
};

/** @internal */
export const DtoInvoiceResponse$inboundSchema: z.ZodMiniType<
  DtoInvoiceResponse,
  unknown
> = z.pipe(
  z.object({
    adjustment_amount: types.optional(types.string()),
    amount_due: types.optional(types.string()),
    amount_paid: types.optional(types.string()),
    amount_remaining: types.optional(types.string()),
    billing_period: types.optional(types.string()),
    billing_reason: types.optional(types.string()),
    billing_sequence: types.optional(types.number()),
    coupon_applications: types.optional(
      z.array(DtoCouponApplicationResponse$inboundSchema),
    ),
    created_at: types.optional(types.string()),
    created_by: types.optional(types.string()),
    currency: types.optional(types.string()),
    customer: types.optional(DtoCustomerResponse$inboundSchema),
    customer_id: types.optional(types.string()),
    description: types.optional(types.string()),
    due_date: types.optional(types.string()),
    environment_id: types.optional(types.string()),
    finalized_at: types.optional(types.string()),
    id: types.optional(types.string()),
    idempotency_key: types.optional(types.string()),
    invoice_number: types.optional(types.string()),
    invoice_pdf_url: types.optional(types.string()),
    invoice_status: types.optional(InvoiceStatus$inboundSchema),
    invoice_type: types.optional(InvoiceType$inboundSchema),
    line_items: types.optional(
      z.array(DtoInvoiceLineItemResponse$inboundSchema),
    ),
    metadata: types.optional(z.record(z.string(), types.string())),
    overpaid_amount: types.optional(types.string()),
    paid_at: types.optional(types.string()),
    payment_status: types.optional(PaymentStatus$inboundSchema),
    period_end: types.optional(types.string()),
    period_start: types.optional(types.string()),
    refunded_amount: types.optional(types.string()),
    status: types.optional(Status$inboundSchema),
    subscription: types.optional(
      z.lazy(() => DtoSubscriptionResponse$inboundSchema),
    ),
    subscription_id: types.optional(types.string()),
    subtotal: types.optional(types.string()),
    taxes: types.optional(z.array(DtoTaxAppliedResponse$inboundSchema)),
    tenant_id: types.optional(types.string()),
    total: types.optional(types.string()),
    total_discount: types.optional(types.string()),
    total_prepaid_credits_applied: types.optional(types.string()),
    total_tax: types.optional(types.string()),
    updated_at: types.optional(types.string()),
    updated_by: types.optional(types.string()),
    version: types.optional(types.number()),
    voided_at: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "adjustment_amount": "adjustmentAmount",
      "amount_due": "amountDue",
      "amount_paid": "amountPaid",
      "amount_remaining": "amountRemaining",
      "billing_period": "billingPeriod",
      "billing_reason": "billingReason",
      "billing_sequence": "billingSequence",
      "coupon_applications": "couponApplications",
      "created_at": "createdAt",
      "created_by": "createdBy",
      "customer_id": "customerId",
      "due_date": "dueDate",
      "environment_id": "environmentId",
      "finalized_at": "finalizedAt",
      "idempotency_key": "idempotencyKey",
      "invoice_number": "invoiceNumber",
      "invoice_pdf_url": "invoicePdfUrl",
      "invoice_status": "invoiceStatus",
      "invoice_type": "invoiceType",
      "line_items": "lineItems",
      "overpaid_amount": "overpaidAmount",
      "paid_at": "paidAt",
      "payment_status": "paymentStatus",
      "period_end": "periodEnd",
      "period_start": "periodStart",
      "refunded_amount": "refundedAmount",
      "subscription_id": "subscriptionId",
      "tenant_id": "tenantId",
      "total_discount": "totalDiscount",
      "total_prepaid_credits_applied": "totalPrepaidCreditsApplied",
      "total_tax": "totalTax",
      "updated_at": "updatedAt",
      "updated_by": "updatedBy",
      "voided_at": "voidedAt",
    });
  }),
);

export function dtoInvoiceResponseFromJSON(
  jsonString: string,
): SafeParseResult<DtoInvoiceResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DtoInvoiceResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DtoInvoiceResponse' from JSON`,
  );
}
